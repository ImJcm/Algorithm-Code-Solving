package BackJoon;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

/*
스타트링크 타워 스페셜 저지

시간 제한	메모리 제한	제출	정답	맞힌 사람	정답 비율
2 초	128 MB	3905	1166	848	28.853%
문제
스타트링크 타워는 총 10N개 층이 있는 고층 건물이고, 0층부터 10N-1층으로 번호가 매겨져 있다. 층 번호를 숫자 N개로 표현한다. 숫자 N개로 층 번호를 표시할 수 없는 경우 앞에 0을 채운다.

숫자 1개를 표현하려면 전구 5×3개가 필요하고, 이 전구를 세로 크기 5, 가로 크기 3인 격자 형태로 배치한다. 다음은 0부터 9까지 숫자를 나타낸 것이다. '#'는 불이 켜져있는 전구, '.'는 불이 꺼져있는 전구이다.

###...#.###.###.#.#.###.###.###.###.###
#.#...#...#...#.#.#.#...#.....#.#.#.#.#
#.#...#.###.###.###.###.###...#.###.###
#.#...#.#.....#...#...#.#.#...#.#.#...#
###...#.###.###...#.###.###...#.###.###
엘리베이터에 있는 층 번호 안내판의 상태가 주어진다. 안내판의 각 숫자는 불이 꺼져있는 전구 한 열로 구분되어 있다. 안내판의 일부 전구는 고장이 나서 항상 꺼져있는 상태이다. 꺼져있는 전구의 일부가 고장이 났다고 가정할 때, 현재 층 번호 안내판이 나타내고 있다고 볼 수 있는 모든 층 번호의 평균을 구해보자.

입력
첫째 줄에 N이 주어진다. N은 9보다 작거나 같은 자연수이다. 둘째 줄부터 다섯 개의 줄에는 엘리베이터 층 번호 안내판의 상태가 주어진다. 각 문자열의 길이는 4N-1이다.

출력
첫째 줄에 층 번호 안내판이 나타내고 있다고 가정할 수 있는 모든 층 번호의 평균을 출력한다. 만약, 가능한 층 번호가 없는 경우 -1을 출력한다.

정답과의 절대/상대 오차는 10-5까지 허용한다.

예제 입력 1
1
###
#.#
###
#.#
###
예제 출력 1
8.0
8만 가능하다.

예제 입력 2
2
###.###
#.#.#.#
#.#.###
#.#...#
###.###
예제 출력 2
48.5
모든 꺼있는 전구가 고장나지 않았다고 하면 "09"를 나타내고 있는 것이다. 일부가 고장났다고 가정하면 '0'과 '9'는 모두 '8'을 나타낼 수 있다.

따라서, 가능한 층 번호는 "08", "09", "88", "89"를 표현할 수 있다. 따라서, 평균은 (8+9+88+89)/4 = 48.5이다.

예제 입력 3
2
.......
.......
.......
.......
.......
예제 출력 3
49.5
0부터 99까지 모든 층을 표현할 수 있다.

예제 입력 4
1
...
.#.
...
...
...
예제 출력 4
-1
출처
문제를 번역한 사람: baekjoon
잘못된 조건을 찾은 사람: WeissBlume
알고리즘 분류
수학
구현
확률론
 */
public class BOJ1089 {
    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    static int N;
    static double avg;
    static char[][] signboard;
    static char[][] numberboard;

    public static void main(String[] args) throws IOException {
        init_setting();

        solve();
    }

    private static void solve() {
        for(int n = 0; n < N; n++) {
            char[][] board = new char[5][3];

            for(int r = 0; r < 5; r++) {
                for(int c = 0; c < 3; c++) {
                    board[r][c] = signboard[r][4 * n + c];
                }
            }


        }
    }

    private static void init_setting() throws IOException {
        N = Integer.parseInt(br.readLine());

        signboard = new char[5][4 * N - 1];

        for(int i = 0; i < N; i++) {
            signboard[i] = br.readLine().toCharArray();
        }

        numberboard = new char[][] {
                {'#','#','#','#','.','#','#','#','#','#','.','#','#','#','#'},  // 0
                {'.','.','#','.','.','#','.','.','#','.','.','#','.','.','#'},  // 1
                {'#','#','#','.','.','#','#','#','#','#','.','.','#','#','#'},  // 2
                {'#','#','#','.','.','#','#','#','#','.','.','#','#','#','#'},  // 3
                {'#','.','#','#','.','#','#','#','#','.','.','#','.','.','#'},  // 4
                {'#','#','#','#','.','.','#','#','#','.','.','#','#','#','#'},  // 5
                {'#','#','#','#','.','.','#','#','#','#','.','#','#','#','#'},  // 6
                {'#','#','#','.','.','#','.','.','#','.','.','#','.','.','#'},  // 7
                {'#','#','#','#','.','#','#','#','#','#','.','#','#','#','#'},  // 8
                {'#','#','#','#','.','#','#','#','#','.','.','#','#','#','#'}   // 9
        };
    }
}
