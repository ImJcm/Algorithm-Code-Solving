package BackJoon;

/*
숨바꼭질 5

시간 제한	메모리 제한	제출	정답	맞힌 사람	정답 비율
0.25 초	512 MB	15885	3784	2621	24.181%
문제
수빈이는 동생과 숨바꼭질을 하고 있다. 수빈이는 현재 점 N(0 ≤ N ≤ 500,000)에 있고, 동생은 점 K(0 ≤ K ≤ 500,000)에 있다. 수빈이는 걷거나 순간이동을 할 수 있다. 만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다. 순간이동을 하는 경우에는 1초 후에 2*X의 위치로 이동하게 된다. 동생은 항상 걷기만 한다. 동생은 항상 매 초마다 이동을 하며, 이동은 가속이 붙는다. 동생이 이동하는 거리는 이전에 이동한 거리보다 1을 더한 만큼 이동한다. 즉, 동생의 처음 위치는 K, 1초가 지난 후 위치는 K+1, 2초가 지난 후 위치는 K+1+2, 3초가 지난 후의 위치는 K+1+2+3이다.

수빈이와 동생의 위치가 주어졌을 때, 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 구하는 프로그램을 작성하시오. 동생을 찾는 위치는 정수 좌표이어야 하고, 수빈이가 0보다 작은 좌표로, 50만보다 큰 좌표로 이동하는 것은 불가능하다.

입력
첫 번째 줄에 수빈이가 있는 위치 N과 동생이 있는 위치 K가 주어진다. N과 K는 정수이다.

출력
수빈이가 동생을 찾는 가장 빠른 시간을 출력한다. 수빈이가 동생을 찾을 수 없거나, 찾는 위치가 500,000을 넘는 경우에는 -1을 출력한다.

예제 입력 1
5 17
예제 출력 1
2
예제 입력 2
17 5
예제 출력 2
4
예제 입력 3
6 6
예제 출력 3
0
예제 입력 4
1 500000
예제 출력 4
-1
예제 입력 5
250000 499999
예제 출력 5
1
예제 입력 6
1 10
예제 출력 6
6
출처
문제를 만든 사람: baekjoon
데이터를 추가한 사람: dlwocks31, kravi
알고리즘 분류
그래프 이론
그래프 탐색
너비 우선 탐색
 */
/*
문제를 읽고 "수빈"이가 이동할 수 있는 위치와 시간에 따른 동생의 위치한 곳을 비교하여 시간을 출력하는 방식을 사용하는 경우
수빈이가 이동할 수 있는 모든 위치를 고려해야 하기 때문에 BFS를 사용하여 이동할 수 있는 위치는 다른 시간을 갖는 중복된 위치의 정보를
무수히 많이 가질 수 있는 문제로 시간초과 문제가 발생할 수 있다고 판단할 수 있었다.

0초 5                        | 17
1초 4 6 10                   | 18
2초 3 5 8 / 5 7 12 / 9 11 20 | 20

5 위치에서 중복이 발생하고 N,K의 간격이 클수록 중복되는 위치와 수많은 위치 정보를 Queue에 담게된다.

그래서 이를 일반적인 BFS문제로 접근하면 안된다고 생각하여 다른 접근 방법을 찾아야 한다.

예제를 기준으로 시뮬레이션을 돌렸을 때
N = 5, K = 17

0초 5                        | 17
1초 4 6 10                   | 18
2초 3 5 8 / 5 7 12 / 9 11 20 | 20

N = 17, K = 5

0초 17                               | 5
1초 16 18 34                         | 6
2초 15 17 32 / 17 19 36 / 33 35 68   | 8
3초 14 15 30 / 16 18 34 / 31 33 64
    16 18 34 / 18 20 38 / 35 37 72
    32 34 66 / 34 36 70 / 67 69 136  | 11
4초 13 15 28 / ...                   | 15

위 시뮬레이션 결과를 통해 어떤 방법으로 동일한 위치에 시간을 유추할 수 있을까 고민했을 때

다음과 같은 접근 방법을 떠올릴 수 있었다.

2 번째 예제에서 동일한 위치를 갖는 시간은 4초인 15에서 만나게 되는데 이때 15라는 위치는 17 -> 16 -> 15 -> 14 -> 15와 같다.

15초를 처음 도달하는 시간은 2초 다음으로 도달하는 시간은 4초로 X 위치에서 다시 X로 돌아오거나 X+2, X-2로 가는 위치에서의 걸리는 시간은
X에 도달한 시간의 + (2 * a)라는 규칙을 알아낼 수 있었다.

이는 5 위치에 최초 도달 시간이 2라면, 4, 6, 8, ... 의 시간에서 동일한 위치에 있을 수 있음을 나타낸다.

하지만, 이 규칙은 X-1, X+1의 이동에서는 적용되었지만 2*X의 경우 반례를 통해 적용되지 않음을 확인할 수 있다.

N = 5
0초 5
1초 4 6 10
2초 3 5 8 / 5 7 12 / 9 11 20
3초 2 4 6 / 4 6 10 / 7 9 16
    4 6 10 / 6 8 14 / 11 13 24
    8 10 18 / 10 12 22 / 19 21 40
2초와 3초에서 8이 다른 시간에 해당 위치에서 중복되는 것을 볼 수 있다.

즉, 2초, 4초, 6초, .... 일 때, 8이라는 위치에 있을 수 있고, 3초, 5초, 7초, 9초, ... 일 때, 8이라는 위치에 있을 수 있다는 의미이다.

접근 방법을 달리 생각하여 X 위치에 짝수, 홀수 시간이 동시에 존재한다면 동생이 X 위치에 어느 시간에 오더라도 짝수, 홀수 시간대에 수빈이가
최초로 도달한 시간보다 동생이 이동한 시간이 지나서 도달한 경우 동시에 만나는 것이 가능하다는 것이다.

또한, X 위치에 최초 도달 시간 이후에 도착해야 동시에 만나는 것이 가능하므로 위 두 조건을 적용하면 다음과 같은 규칙을 만들 수 있다.

1. 수빈이가 이동할 수 없는 위치는 -1로 기록하고 이동할 수 있는 위치는 최초 도달 시간을 짝수, 홀수 시간대를 각각 기록한다.
2. X 위치에서 짝수 시간의 최초 도달 시간이 존재하면 최초 도달 시간 + (2 * @)의 시간에 X에 도착하는 경우는 만날 수 있음을 만족한다.
3. X 위치에서 홀수 시간의 최초 도달 시간이 존재하면 최초 도달 시간 + (2 * @)의 시간에 X에 도착하는 경우는 만날 수 있음을 만족한다.

위 규칙을 적용하면 +1, -1, *2의 이동에 따른 두 사람의 만나는 위치의 최소 시간을 측정할 수 있다.
(N = 5일 때, 8의 위치에서 2 + (2 * @), 3 + (2 * @)의 시간에서는 모두 만날 수 있다. <- 짝수, 홀수 시간대 별로 최초 도달 시간이 필요한 이유)

알고리즘 핵심
BFS
1. 수빈이가 이동할 수 있는 위치의 최초 도달 시간을 짝수, 홀수로 나누어 저장한다.
2. 동생이 이동한 위치에서 걸린 시간의 짝수, 홀수를 구분한 후 수빈이의 최초 도달 시간과 비교하여 수빈이가 최초로 걸린 시간보다 동생이 도착한 시간보다
작거나 같다면 동시에 만날 수 있음을 만족하기 때문에 해당 시간을 최소를 만족하는 동시에 만나는 시간으로 ans를 업데이트한다.
 */
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.LinkedList;
import java.util.Queue;

public class BOJ17071 {
    static class BOJ17071_pos {
        int n,t;

        BOJ17071_pos(int n, int t) {
            this.n = n;
            this.t = t;
        }
    }
    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    static int N,K,ans;
    static int[][] visited_first_time;

    public static void main(String[] args) throws IOException {
        init_setting();

        solve();
    }

    private static void solve() {
        bfs(new BOJ17071_pos(N,0));

        search_younger();

        System.out.println(ans);
    }

    private static void bfs(BOJ17071_pos p) {
        Queue<BOJ17071_pos> q = new LinkedList<>();
        visited_first_time = new int[500001][2];

        for(int i = 0; i <= 500000; i++) {
            visited_first_time[i][0] = visited_first_time[i][1] = -1;
        }

        q.add(p);
        visited_first_time[p.n][p.t % 2] = p.t;

        while(!q.isEmpty()) {
            BOJ17071_pos now = q.poll();

            for(int i = 0; i < 3; i++) {
                int next_n = now.n;

                switch (i) {
                    case 0:
                        next_n -= 1;
                        break;
                    case 1:
                        next_n += 1;
                        break;
                    case 2:
                        next_n *= 2;
                        break;
                }

                if(next_n < 0 || next_n > 500000) continue;
                if(visited_first_time[next_n][(now.t + 1) % 2] != -1) continue;

                visited_first_time[next_n][(now.t + 1) % 2] = now.t + 1;
                q.add(new BOJ17071_pos(next_n,now.t + 1));
            }
        }
    }

    private static void search_younger() {
        int m = 0;
        int cur_pos = K;

        while(true) {
            cur_pos += m;
            if(cur_pos > 500000) break;

            if(visited_first_time[cur_pos][m % 2] == -1) continue;

            if(visited_first_time[cur_pos][m % 2] <= m) {
                ans = m;
                break;
            }

            m++;
        }
    }

    private static void init_setting() throws IOException {
        String[] input = br.readLine().split(" ");

        N = Integer.parseInt(input[0]);
        K = Integer.parseInt(input[1]);

        ans = -1;
    }
}
