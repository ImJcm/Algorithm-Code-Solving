package DP;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

/*
박스 안의 열쇠

시간 제한	메모리 제한	제출	정답	맞힌 사람	정답 비율
2 초	128 MB	1429	645	515	46.606%
문제
1부터 N까지 번호가 매겨진 박스와 1부터 N까지 번호가 매겨진 열쇠가 있다. i번째 키는 i번째 박스를 열 수 있다.

다못이는 각각의 박스에 정확하게 하나의 열쇠를 무작위로 넣는다. 각각의 열쇠가 박스에 들어갈 확률은 모두 같다고 가정한다. 그러고 나서 박스를 모두 잠근다. 다못이에게는 M개의 폭탄이 있다. 폭탄은 잠겨져 있는 박스를 파괴하는 역할을 한다. 이때 박스 안에 있는 열쇠는 부서지지 않는다. 다못이는 모든 열쇠를 얻고 싶다. 그래서 다음 전략을 사용하기로 했다.

우선 잠겨져 있는 박스 하나를 선택해서 폭탄으로 파괴하고 열쇠를 얻는다. 각각의 잠겨져 있는 박스가 선택될 확률은 모두 같다. 그 열쇠로 열 수 있는 박스가 있으면 열고, 그 박스 속의 열쇠로 열 수 있는 박스가 있으면 또 열고, 이를 열 박스가 더 이상 없을 때까지 반복한다. 그러고 나서 폭탄이 남았으면 그 폭탄을 이용해서 이 전략을 반복한다.

다못이가 모든 열쇠를 얻을 확률을 구하는 프로그램을 작성하시오.

입력
첫째 줄에 박스와 열쇠의 개수 N과 폭탄의 개수 M이 공백을 사이에 두고 주어진다. N은 20보다 작거나 같은 자연수이고, M은 N보다 작거나 같은 자연수이다.

출력
다못이가 모든 열쇠를 얻을 확률을 A/B 형태로 출력한다. A와 B는 최대공약수가 1인 자연수이다.

예제 입력 1
2 1
예제 출력 1
1/2
예제 입력 2
2 2
예제 출력 2
1/1
예제 입력 3
3 1
예제 출력 3
1/3
예제 입력 4
3 2
예제 출력 4
5/6
예제 입력 5
4 2
예제 출력 5
17/24
힌트
예제 1의 경우 1번 박스에 열쇠2가 들어있으면, 모든 키를 얻을 수 있다.

출처
문제의 오타를 찾은 사람: adfsfsf, YunGoon
문제를 번역한 사람: baekjoon
문제를 다시 작성한 사람: jh05013
알고리즘 분류
수학
다이나믹 프로그래밍
조합론
 */
/*
알고리즘 핵심
DP
처음으로 bruteforce로 문제를 구현할 경우, 1~i번째 박스마다 열쇠를 구성하는 로직(O(N!))
+ 구성이 완료된 박스들을 검증하는 로직(n_C_m * n-m_C_m * n-2m_C_m * ... * 1 == N!)
이므로 시간초과가 발생할 것으로 예상할 수 있다.

따라서, TC를 분석하여 다른 해결방법을 찾아야 했다.
각 케이스마다 모든 경우의 수를 보고 규칙을 찾으려고 하였다.
N = 3, M = 1) 2/6
A   B   C   - Box
a   b   c   - (A,B,C 어느 것을 먼저 열어도) 불가능한 경우
a   c   b   - (...) 불가능
b   a   c   - (...) 불가능
b   c   a   - (...) 가능
c   a   b   - (...) 가능
c   b   a   - (...) 불가능

N = 3, M = 2) 5/6
A   B   C   - Box
a   b   c   - (A,B / B,C / A,C를 열어도) 불가능한 경우이므로 불가능
a   c   b   - (A,B / A,C) 가능한 경우이고, (B,C) 불가능한 경우이므로 가능
b   a   c   - (A,C / B,C) 가능한 경우이고, (A,B) 불가능한 경우이므로 가능
b   c   a   - (A,B / A,C / A,B) 가능한 경우이므로 가능
c   a   b   - (A,B / A,C / B,C) 가능한 경우이므로 가능
c   b   a   - (A,B / B,C) 가능한 경우이고, (A,C) 불가능한 경우이므로 가능

이 경우를 통해 규칙을 (N,M) -> (남은 박스의 수, 남은 열수있는 횟수)라고 했을 때
(3,1) -> (2,1) ->   (1,1) ->    (1,0)
      -> (2,0)  \-> (1,0)  \->  (0,0)

(3,2) ->    (2,1) ->   (1,1) ->    (1,0)
       \           \-> (1,0)  \->  (0,0)
        \->  (2,2) ->  (1,1) ->    (0,0)
(0,0)의 횟수가 모든 열쇠를 얻는 경우의 수로 결정할 수 있다고 생각했지만 생각한 대로 모든 경우의 수가 도출되지 않았다.
또한, (2,1)이 만족되는 구성에 어떠한 박스가 먼저 선택되었는지에 따라 선택되므로 해당 가지수를 곱해야하는지 결정해야 하는데 알 수 없었다.

결론적으로 이 방법은 올바르지 않은 방법이라고 판단하였고, 더이상 해결 방법이 떠오르지 않아 정답 코드와 설명을 참고하였다. - https://peisea0830.tistory.com/49

알고리즘 분석
1. 박스의 개수가 i일 때 구성할 수 있는 경우에서 필요한 폭탄의 개수가 박스를 추가할 때(i + 1) 필요한 폭탄의 개수가 파생되어 늘어난다.
ex) 1 2 -> A박스를 오픈할 때, 모든 열쇠를 얻기 위해 필요한 폭탄의 개수는 2개
    2 1 -> //               모든 열쇠를 얻기 위해 필요한 폭탄의 개수는 1개

    N = 3의 경우, ?에 박스를 추가로 할 수 있다.
    ? 1 ? 2 ?
    -> 첫번째 ?에 3을 넣는 경우, 3 -> 2 -> 1로 단 하나의 폭탄으로 모든 열쇠를 얻을 수 있다.
    -> 두번째 ?에 3을 넣는 경우, 1 / 3 -> 2로 두개의 폭탄으로 모든 열쇠를 얻을 수 있다.
    -> 세번째 ?에 3을 넣는 경우, 1 / 2 / 3로 세개의 폭탄으로 모든 열쇠를 얻을 수 있다.

    ? 2 ? 1 ?
    -> 첫번째 ?에 3을 넣는 경우, 3 -> 1 / 2로 두개의 폭탄으로 모든 열쇠를 얻을 수 있다.
    -> 두번째 ?에 3을 넣는 경우, 2 -> 3 -> 1로 한개의 폭탄으로 모든 열쇠를 얻을 수 있다.
    -> 세번째 ?에 3을 넣는 경우, 2 -> 1 / 3로 두개의 폭탄으로 모든 열쇠를 얻을 수 있다.

    위의 경우처럼 이전의 경우로 부터 현재의 경우와 같이 폭탄의 개수가 파생되므로 다이나믹 프로그래밍이 가능한 것을 알 수 있다.
2. 남은 박스의 개수 1~i번까지 있을 때, 폭탄 j개를 사용할 때 전체 상자를 열 수 있는 경우의 수라고 정의하여 dp[i][j] 메모리제이션을 사용한다.
2-a) 박스를 i + 1에 추가하는 경우, 맨 두 빈칸에 붙이면 상자의 순서가 그대로 유지되고 모든 열쇠를 얻기 위해 폭탄의 수 1개만 추가하면 된다.
2-b) 박스를 마지막에 추가하는 것이 아닌 경우, 마지막 빈칸을 제외한 나머지 빈칸의 갯수를 i-1개의 박스와 j개의 폭탄으로 구성되어 있는 경우의 수를 곱한다.

따라서 점화식은 dp[i][j] = dp[i-1][j-1] + (i-1) * dp[i-1][j]

+ dp의 값과 분자와 분모의 값이 int의 범위를 넘어갈 수 있으므로 long을 사용한다.
*/
public class BOJ1413 {
    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    static int N,M;
    static long[][] dp;

    public static void main(String[] args) throws IOException {
        init_setting();

        solve();
    }

    private static void solve() {
        for(int i = 2; i < N + 1; i++) {
            for(int j = 1; j < i + 1; j++) {
                dp[i][j] = dp[i - 1][j - 1] + (i - 1) * dp[i - 1][j];
            }
        }

        long bunja = 0;
        long bunmo = 1;

        // N개의 상자가 있을 때, M개의 폭탄으로 모든 열쇠를 얻을 수 있는 경우의 수
        for(int i = 1; i < M + 1; i++) {
            bunja += dp[N][i];
        }

        // 상자 N개일 때 모든 경우의 수는 N!
        for(int i = 1; i < N + 1; i++) {
            bunmo *= i;
        }

        //long gcd = gcd(bunja, bunmo);
        long gcd = gcd_2(bunja, bunmo);

        System.out.println((bunja / gcd) + "/" + (bunmo / gcd));
    }

    // 두 수의 최대 공약수를 찾는 함수 - 시간초과 발생 원인
    private static long gcd(long l, long r) {
        long gcd = 1;

        long m = Math.min(l, r);

        for(int i = 2; i < m + 1; i++) {
            if(l % i == 0 && r % i == 0) {
                gcd *= (i * gcd(l / i, r / i));
                break;
            }
        }

        return gcd;
    }

    // 두 수의 최대 공약수를 찾는 함수 2
    private static long gcd_2(long r, long l) {
        return (l > 0) ? gcd_2(l, r%l) : r;
    }

    private static void init_setting() throws IOException {
        String[] input = br.readLine().split(" ");

        N = Integer.parseInt(input[0]);
        M = Integer.parseInt(input[1]);

        dp = new long[21][21];

        dp[1][1] = 1;
    }
}
